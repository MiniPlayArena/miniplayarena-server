from typing import Optional

class Game:

    def __init__(self, max_players: int, name: str, player_ids: str, min_players: int = 1):
        
        self.player_constraints = (min_players, max_players)
        self.num_players = len(player_ids)
        self.players = player_ids

        self.name = name
        self.current_player = 0
        self.next_player = 1 if len(self.players) > 1 else 0
        self.winner = ""
        
    def update_player_pointers(self, reverse: bool=False) -> None:
        """ Updates the player pointers once a turn has been taken

        args:
            reverse(bool): Whether or not the direction of players should be cw (false) or acw (true)
        """
        self.current_player = self.next_player
        self.next_player += -1 if reverse else 1
        self.next_player %= self.num_players

    def get_active_player(self) -> int:
        """Gets the player who's turn it is next.

        args:
            None
        
        returns:
            (int): The player that is next to play
        """
        return self.current_player

    def get_client_data(self, player: str) -> dict:
        """Gets all the data that the player needs at a given time point as a JSON encoded dict
        
        Called at the end of take_turn, but can be called whenever you want to explicitly
        get data to update a certain client (for whatever reason)

        Call this when you want to get all the data that is relevant to a certain client's
        frontend stuff, so probably whenever the game state has changed

        args:
            player(int): index of the player to get the data for
        
        returns:
            JSON encoded data :D
        """
        raise NotImplementedError("Implement this please :DDD")

    def get_player_id(self, player_index: int) -> str:
        return self.players[player_index]
    
    def get_player_index(self, player_id: str) -> int:
        return self.players.index(player_id)

    def get_all_client_data(self) -> dict:
        """Gets all the data for ALL the clients and returns in JSON format

        args:
            None

        returns:
            Json dictionary with the entire game state. Dont send this to all players please :D
        """
        return {"game-state": {player: self.get_client_data(player) for player in self.players}}

    def take_turn(self, incoming_player: int, turn_data: dict) -> dict:
        """Updates the game state based on what the player has sent

        Call this when you want to update the state of the game on the server based on the inputs
        of the player

        args:
            incoming_player(int): the id of the player that has sent the information
            turn_data(dict): json-encoded data of the turn that the player would make (should be
            generated by frontend probably)
        
        returns:
            a dictionary containing the data to send to each client based on the turn that was played
        """
        raise NotImplementedError("Implement this one too :(")

    def is_valid_playercount(self) -> bool:
        """ Checks if the given number of players is allowed

        args:
            players(int): the number of players that the game is trying to be initialised with
        
        returns:
            is the player count valid
        """
        return self.player_constraints[0] <= self.num_players <= self.player_constraints[1]


    def get_final_gamestate(self) -> dict:
        c_data = self.get_all_client_data()
        return {p.update({"winner": self.winner}): c_data[p] for p in c_data}


    def game_is_won(self) -> str:
        """Gets whether or not the game has been won
        
        args:
            None

        returns:
            The condition of the game
        """
        raise NotImplementedError("Please implement a win condition")

    def remove_player(self, player: str) -> None:
        """Removes a player from the game in the case of a disconnect

        args:
            player(str): the id of the player to be removed
        """
        raise NotImplementedError("Please implement player removal logic")


def create_game(game_id: str, players: [str]) -> Optional[Game]:
    """Creates a game given the game id and the players present in the party

    args:
        game_id(str): the id of the game that should be played
        players(list(str)): the list of player ids
    
    returns:
        a game if the player count was valid, else returns None
    """
    r_val = None
    if game_id == "uno":
        import games.uno as uno
        r_val = uno.Uno(players)
    elif game_id == "snakes":
        import sal
        r_val =  sal.SnakesAndLadders(players)
    r_val = None if (not r_val or not r_val.is_valid_playercount()) else r_val
    return r_val, "Not enough players to start the game. Get more friends and then retry ðŸ¤“" if not r_val else None

if __name__ == "__main__":
    u = create_game("uno", ["jopat2409", "nexinfinite", "cactusjack", "1blademaster"])
    while 1:
        for player in  ["jopat2409", "nexinfinite", "cactusjack", "1blademaster"]:
            u.take_turn(player, {"played-card": 0})